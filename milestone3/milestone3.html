<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">    
    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="../myStyles.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Condensed|Saira+Extra+Condensed" rel="stylesheet">
    <title>Milestone 3 | Team Firework</title>
  </head>

  <body>
  	<!-- Page header -->
  	<div class="page-header">
  		<div class="container-fluid">
		<h1 align="center"><span style="color:#fad5a6"><b>Team Firework</b></span></h1>
		<h3 align="center"><span style="color:#fad5a6">Milestone 3</span></h3>
		</div>
		<!--<div class="container" align="center">
			<audio src="audio/firework.mp3" loop="loop" controls controlsList="nodownload"><p>Oh no! You can't hear our music.</p></audio>
		</div>-->
  	</div>

  	<!-- Navigation bar -->
  	<nav class="navbar navbar-default">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <!--<div class="container-fluid">
      <a href="#"><span class="glyphicon glyphicon-star-empty"></span></a>-->
  	  </div>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="index.html">Home<span class="sr-only">(current)</span></a></li>
        <li><a href="team.html">Team</a></li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Assignments <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../lab1/lab1.html">Lab 1</a></li>
            <li><a href="../lab2/lab2.html">Lab 2</a></li>
            <li><a href="../lab3/lab3.html">Lab 3</a></li>
            <li><a href="../lab4/lab4.html">Lab 4</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="../milestone1/milestone1.html">Milestone 1</a></li>
            <li><a href="../milestone2/milestone2.html">Milestone 2</a></li>
            <li><a href="../milestone3/milestone3.html">Milestone 3</a></li>
            <li><a href="../milestone3/milestone3.html">Milestone 4</a></li>
          </ul>
        </li>
        <li><a href="../tutorials.html">Tutorials</a></li>
      </ul>
      <!--A search bar -->
      <!--<form class="navbar-form navbar-left">
        <div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>
      </form>-->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>
    
  <!--Page content -->
  <div class="body-content">
	<h1>Depth First Search</h1>
	<p>The algorithm we chose to use for our robot is the depth-first search. In depth-first search, we search a tree structure by going down to the lowest leaf node, then it traverses back up the tree to look for the next unexplored node. We chose this algorithm because our nodes, which reperesent grid squares in the maze, are adjacent to each other on the tree, so using a depth-first search would be most efficient in order to prevent doing unnecessary traveling. In addition, depth-first search has lower memory requirements than breadth-first search, making it very ideal for a limited-memory microprocessor like the Arduino.</p>
	<hr>
	<h1>Implementing the Tree</h1>
	<p>To implement our tree structure for the maze, we created the class Node. Node will represent each square of the grid. This structure will keep track of all the coordinate, wall, and treasure info for that particular grid space. It also keeps track of the grid's neighbors, and where the robot has come from to reach that grid space (parent Node). Below our Node header file.</p>
	<pre class="prettyprint">
class Node {

  int dir; 
  char coord; //0-19

  //NSEWTTTF: NSEW = walls, TT = treasure, F = flag for done exploring
  char wallTreasures;
  
  Node* neighbors[3]; //pointer to neighboring nodes
  Node* parent; //pointer to parent node
  
  int nextNeighbor;

  public:
    Node(int);
    void addNeighbor(Node*);
    void addWall(Direction, bool);
    bool isExplored();
    void addTreasure(int freq);
    void addParent(Node*);
    void markAsExplored();
    Node** getNeighbors();
    Node* getParent();
    char getCoord();
    char getWallTreasures();
    int neighborCoord(Direction facing, int sensor, int currPos);
};
	</pre>
	<p>There are a few difficulties in representing a maze as a tree. The biggest problem is that our maze "tree" isn't necessarily a tree, it could be a graph. This means that if we have 4 grids arranged in a square, there is a possibility that our robot would be stuck in that loop and exploring those nodes over and over without ever moving on to a different node. This was taken care of using a flag bit in <code>wallTreasures</code>. When a Node has been expanded (meaning that we have looked at its walls and neighbors), this flag signals that the node has been fully explored. Next time, if we see this Node, we do not add it to the tree, and we do not explore it again.</p>
	<hr>
	<h1>Implementing the DFS</h1>
	<p>Now that we have set up our Node structure, we have to implement the DFS itself. This is actually done in another class we called Explorer, whose header file is shown here.</p>
	<pre class="prettyprint">
class Explorer {

  Node* root;
  Node* current;

  public:
    Explorer(Node* startNode);    
    Node* nextNode(); //essentially does the DFS
    Node* travelTo(Node*); //call this when robot has moved
    Node* getCurrNode(); //returns current node
    bool isDone();
  
};
	</pre>
	<p> This class has all the logic for searching/processing. The tree needs only the information regarding the root Node, and the current Node the robot is at. It does not even need to save a "frontier" or array of nodes to explore, since it will simply traverse up and down the tree, based on whether the current Node has unexplored neighbors. In essence, we are saving only one node at all times!! :D</p>
	<p>To quickly note, the reason that the search algorithms have a frontier list is because the tree structures assumed there do not have a <code>parent</code> as we've specified in our Node class. With our structure, we are able to see what Nodes we are coming from by simply traversing back up the tree.</p>
	<hr>
	<h1>Robot Implementation</h1>
	<p>Now that we've discussed the classes we wrote that implement the tree and searching, we can finally talk about the big idea of how we're implementing our robot. (You're almost there, TAs!) The idea is that as our robot traverses the maze, it builds a tree using our Node class. We initialize all 20 Nodes in <code>setup()</code>, since our maze is a fixed size. As the robot explores, it builds the neighbor/parent connections as we've set up in our tree.</p>
	<p></p>
</div>



    <!-- Footer -->
    <div id="footer">
      <div class="container">
        <p class="muted credit" align="center">Brought to you by Team Firework. Have an explosive day!</p>
      </div>
    </div>

    <!-- Bootstrap core JavaScript -->
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>


  </body>

</html>
